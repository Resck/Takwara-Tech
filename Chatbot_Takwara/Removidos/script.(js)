// docs/assets/js/script.js - VERSÃO MESTRE FINALÍSSIMA - TUDO-EM-UM E COMPLETO

// ===================================================================
// SEÇÃO 1: OUVINTE PRINCIPAL (ORQUESTRADOR)
// ===================================================================
document.addEventListener("DOMContentLoaded", function() {
    console.log("DOM carregado. Construindo e inicializando a Toolbox...");

    const toolboxPanel = document.createElement('div');
    toolboxPanel.className = 'takwara-push-sidebar';
    const toolboxContent = document.createElement('div');
    toolboxContent.className = 'takwara-toolbox-content';
    toolboxPanel.appendChild(toolboxContent);
    document.body.appendChild(toolboxPanel);

    const triggerButton = document.createElement('button');
    triggerButton.textContent = 'Toolbox';
    triggerButton.className = 'takwara-toolbox-trigger';
    document.body.appendChild(triggerButton);

    const widget_ids = ['takwara-chatbot-template', 'takwara-tools-template', 'takwara-calculadora-template', 'takwara-grafo-template'];
    widget_ids.forEach(id => {
        const template = document.getElementById(id);
        if (template) toolboxContent.appendChild(template.content.cloneNode(true));
    });

    triggerButton.addEventListener('click', () => {
        document.body.classList.toggle('toolbox-is-open');
        toolboxPanel.classList.toggle('is-open');
    });

    // CHAMA AS FUNÇÕES PARA "LIGAR" OS WIDGETS
    initializeTakwaraChatbot();
    initializeTakwaraCalculator();
    initializeGrafo();
});

// ===================================================================
// SEÇÃO 2: LÓGICA COMPLETA DO CHATBOT (AVT)
// ===================================================================
function initializeTakwaraChatbot() {
    console.log('Takwara AVT: Inicializando...');
    const API_URL = 'https://southamerica-east1-adroit-citadel-397215.cloudfunctions.net/chatbot-api';
    const chatForm = document.getElementById('chat-form');
    if (!chatForm) return;

    const chatBox = document.getElementById('chat-box');
    const userInput = document.getElementById('user-input');

    chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const userMessage = userInput.value.trim();
        if (!userMessage) return;
        addMessage(userMessage, 'user');
        userInput.value = '';
        try {
            addMessage('...', 'bot-loading');
            const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: userMessage, context: window.location.pathname }) });
            chatBox.querySelector('.bot-loading')?.remove();
            if (!response.ok) throw new Error(`Erro de servidor: ${response.status}`);
            const data = await response.json();
            if (data && data.answer) { addMessage(data.answer, 'bot'); }
            else { addMessage('Desculpe, não consegui processar a resposta.', 'bot'); }
        } catch (error) {
            chatBox.querySelector('.bot-loading')?.remove();
            addMessage('Desculpe, ocorreu um erro de comunicação.', 'bot');
        }
    });

    function addMessage(text, sender) { /* ... lógica addMessage ... */ }
    console.log('Takwara AVT: Inicialização concluída.');
}

// ===================================================================
// SEÇÃO 3: LÓGICA COMPLETA DA CALCULADORA DE DOMOS
// ===================================================================
function initializeTakwaraCalculator() {
    console.log('Calculadora: Inicializando...');
const DOME_DATA = {
    "Icosahedron": {
        "V1": {"truncation": {"2/3": {}}}, "V2": {"truncation": {"1/2": {}}},
        "V3": {"truncation": {"3/8": {}, "5/8": {}}}, "V4": {"truncation": {"1/2": {}}},
        "L3": {"truncation": {"1/2": {}}}, "V5": {"truncation": {"7/15": {}, "8/15": {}}},
        "V6": {"truncation": {"1/2": {}}}, "2V.3V": {"truncation": {"1/2": {}}}
    },
    "Cube": {
        "V1": {"truncation": {"N/D": {}}}, "V2": {"truncation": {"N/D": {}}},
        "V3": {"truncation": {"N/D": {}}}, "V4": {"truncation": {"N/D": {}}},
        "V5": {"truncation": {"~1/2": {}}}, "V6": {"truncation": {"1/2": {}}},
        "2V.3V": {"truncation": {"1/2": {}}}, "3V.2V": {"truncation": {"1/2": {}}}
    },
    "Octahedron": {
        "V1": {"truncation": {"1/2": {}}}, "V2": {"truncation": {"1/2": {}}},
        "V3": {"truncation": {"1/2": {}}}, "L3_3/8": {"truncation": {"3/8": {}}},
        "L3_5/8": {"truncation": {"5/8": {}}}, "V4": {"truncation": {"N/D": {}}},
        "V5": {"truncation": {"N/D": {}}}, "V6": {"truncation": {"N/D": {}}}
    },
    "Dodecahedron": {
        "L1": {"truncation": {"N/D": {}}}, "L2": {"truncation": {"N/D": {}}},
        "L2T": {"truncation": {"N/D": {}}}
    },
    "Tetrahedron": {
        "L2T": {"truncation": {"N/D": {}}}, "L3T": {"truncation": {"N/D": {}}}
    }
};

// URL da API da Calculadora (substitua se necessário)
const apiUrl = 'https://southamerica-east1-adroit-citadel-397215.cloudfunctions.net/calculadora-domo-api';

// Função de arredondamento (mantida)
function customRound(value) {
    if (typeof value !== 'number' || isNaN(value)) return 'N/A';
    return (Math.round(value * 100) / 100).toFixed(2);
}

// --- FUNÇÃO DE INICIALIZAÇÃO DA CALCULADORA ---
function initializeTakwaraCalculator(document) {
    console.log('Takwara Calculator: A inicializar após receber o sinal "tools-ready".');

    // --- SELECIONAR ELEMENTOS DENTRO DO SHADOW DOM ---
    // Verifique se estes IDs estão em partials/widget-calculadora.html
    const calculatorForm = document.getElementById('calculator-form-widget');
    const solidSelect = document.getElementById('base-solid-input-widget');
    const freqSelect = document.getElementById('frequency-input-widget');
    const truncSelect = document.getElementById('truncation-input-widget');
    const poleDiameterInput = document.getElementById('pole-diameter-input-widget');
    const resultsContainer =  document.getElementById('results-container-widget');
    const resultsTableDiv = document.getElementById('results-table-widget');
    const materialCostsDiv = document.getElementById('material-costs-widget');
    const errorMessageP = document.getElementById('error-message-widget');
    const poleDiameterNote = document.getElementById('pole-diameter-note');
    const downloadResultsButton = document.getElementById('download-results-button'); // Botão de download
    const footerNotes = document.getElementById('footer-notes'); // Parágrafo das notas no rodapé dos resultados


    // --- VERIFICAÇÃO ESSENCIAL: Todos os elementos devem existir no Shadow DOM ---
    if (!calculatorForm || !solidSelect || !freqSelect || !truncSelect || !poleDiameterInput || !resultsContainer || !resultsTableDiv || !materialCostsDiv || !errorMessageP || !downloadResultsButton || !footerNotes) {
        console.error('Takwara Calculator: Um ou mais elementos HTML essenciais não foram encontrados no Shadow DOM. Verifique os IDs em `partials/widget-calculadora.html`.');
        // Opcional: logar quais elementos faltam para depuração
        // console.log("Elementos não encontrados:", { calculatorForm, solidSelect, freqSelect, truncSelect, poleDiameterInput, resultsContainer, resultsTableDiv, materialCostsDiv, errorMessageP, downloadResultsButton, footerNotes });
        return; // Aborta a inicialização
    }

    // --- VARIÁVEIS PARA ARMAZENAR DADOS (ESCAPO DE initializeTakwaraCalculator) ---
    // Acessíveis por displayResults e generateMarkdown
    let lastCalculatedData = null; // Dados completos do último cálculo da API + processados
    let lastSelectedSolid = '';
    let lastSelectedFreq = '';
    let lastSelectedTrunc = '';
    let lastPoleDiameterCm = 'N/A';
    // lastTotalLinearMeters, lastVertexDiameterDisplay, lastConnectorLengthCm, etc.
    // Serão armazenados dentro de lastCalculatedData.

    // --- FUNÇÕES AUXILIARES (Dentro de initializeTakwaraCalculator) ---
    function populateSelect(selectElement, options) {
         selectElement.innerHTML = '';
         if (options.length === 0) {
             const opt = document.createElement('option'); opt.value = ""; opt.textContent = "N/D";
             selectElement.appendChild(opt); selectElement.disabled = true;
         } else {
             selectElement.disabled = false;
             options.forEach(option => {
                 const opt = document.createElement('option'); opt.value = option; opt.textContent = option;
                 selectElement.appendChild(opt);
             });
         }
    }

    function updateFreqOptions() {
        const selectedSolid = solidSelect.value;
        const freqs = Object.keys(DOME_DATA[selectedSolid] || {});
        populateSelect(freqSelect, freqs);
        updateTruncOptions();
    }

    function updateTruncOptions() {
        const selectedSolid = solidSelect.value;
        const selectedFreq = freqSelect.value;
        let truncs = [];
        if (DOME_DATA[selectedSolid]?.[selectedFreq]?.truncation) {
            truncs = Object.keys(DOME_DATA[selectedSolid][selectedFreq].truncation);
        }
        populateSelect(truncSelect, truncs);
        if (truncs.length > 0) {
            truncSelect.value = truncs[0];
        } else {
            truncSelect.value = '';
        }
    }

    // --- EVENT LISTENER DO FORMULÁRIO (Usa variáveis e funções do escopo superior) ---
    calculatorForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        // Resetar UI e mensagens
        resultsContainer.style.display = 'none';
        errorMessageP.textContent = '';
        materialCostsDiv.innerHTML = '';
        downloadResultsButton.style.display = 'none'; // Esconde o botão até o cálculo dar sucesso
        footerNotes.style.display = 'none';


        // Pegar valores dos inputs
        const diameter = parseFloat(document.getElementById('diameter-input-widget').value);
        const base_solid = solidSelect.value;
        const frequency = freqSelect.value;
        const truncation = truncSelect.value;

        let poleDiameterCm = parseFloat(poleDiameterInput.value);
        if (isNaN(poleDiameterCm) || poleDiameterCm <= 0) { // Usar isNaN(parseFloat(...)) para verificar
            poleDiameterCm = "N/A";
            if(poleDiameterNote) poleDiameterNote.style.display = 'block';
        } else {
            if(poleDiameterNote) poleDiameterNote.style.display = 'none';
        }

        // Indicador de carregamento
        const loadingIndicator = document.createElement('p');
        loadingIndicator.textContent = 'Calculando...';
        loadingIndicator.id = 'calculator-loading-indicator'; // Adicionar um ID para facilitar a remoção
        if (resultsContainer) resultsContainer.appendChild(loadingIndicator);


        // Montar payload
        const payload = {
            diameter: diameter,
            base_solid: base_solid,
            frequency: frequency,
            truncation: truncation
        };

        try {
            // Chamar a API
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });
            const data = await response.json();

            // Remover indicador de carregamento
            document.getElementById('calculator-loading-indicator')?.remove();

            console.log("Dados da API:", data);

            if (data.success) {
                // --- Processar dados da API e calcular valores adicionais ---

                const SPACING_MM = 4; // Espaçamento fixo para cálculo do vértice
                const SPACING_CM = SPACING_MM / 10;
                let actualConnectorCutoffMeters = 0; // Desconto total em metros (para as duas extremidades)
                let vertexDiameterDisplay = 'N/A';
                let connectorLengthCalculatedCm = 'N/A';


                if (typeof poleDiameterCm === 'number' && poleDiameterCm > 0) {
                    const calculatedVertexDiameter = 2 * (1.5 * poleDiameterCm + SPACING_CM);
                    actualConnectorCutoffMeters = (2 * (calculatedVertexDiameter / 2) / 100); // Duas extremidades em metros

                     // Armazenar para observações e Markdown
                     vertexDiameterDisplay = calculatedVertexDiameter.toFixed(2) + ' cm';
                     connectorLengthCalculatedCm = (calculatedVertexDiameter / 2).toFixed(2); // Comprimento do conector
                }


                let totalLinearMetersCalculated = 0;
                let totalSegmentsCalculated = 0;
                let segmentResultsForDisplay = [];

                // Calcular totais e resultados por segmento
                if (data.segment_lengths && data.num_segments && data.vertex_angles) {
                    for (const key in data.segment_lengths) {
                        const originalLength = parseFloat(data.segment_lengths[key]);
                        const quantity = data.num_segments[key];
                        const vertexAngle = data.vertex_angles[key];

                        // Aplica o desconto
                        let finalLengthM = originalLength - actualConnectorCutoffMeters;

                        totalLinearMetersCalculated += (finalLengthM > 0 ? finalLengthM : 0) * quantity; // Só soma se o comprimento final for positivo
                        totalSegmentsCalculated += quantity;

                        segmentResultsForDisplay.push({
                            type: key,
                            originalLength: originalLength,
                            discount: actualConnectorCutoffMeters,
                            finalLength: finalLengthM,
                            quantity: quantity,
                            angle: vertexAngle
                        });
                    }
                }


                // --- Armazenar TODOS os dados necessários para display E download ---
                lastCalculatedData = {
                    ...data, // Inclui total_vertices, etc.
                    usedPoleDiameterCm: poleDiameterCm, // Diâmetro usado
                    calculatedTotalSegments: totalSegmentsCalculated, // Total calculado de varas
                    calculatedTotalLinearMeters: totalLinearMetersCalculated, // Total calculado de metros lineares
                    segmentResultsForDisplay: segmentResultsForDisplay, // Dados processados dos segmentos
                    calculatedVertexDiameterDisplay: vertexDiameterDisplay, // Diâmetro do vértice
                    calculatedConnectorLengthCm: connectorLengthCalculatedCm, // Comprimento do conector
                     spacingMM: SPACING_MM // Espaçamento para as observações no MD
                };

                // Exibir resultados na UI usando os dados armazenados
                displayResults(document, lastCalculatedData);


                // Armazenar seleções para o nome do arquivo de download
                lastSelectedSolid = base_solid;
                lastSelectedFreq = frequency;
                lastSelectedTrunc = truncation;


                downloadResultsButton.style.display = 'block'; // Mostra o botão de download após sucesso

            } else {
                // Remover indicador de carregamento
                document.getElementById('calculator-loading-indicator')?.remove();
                // Exibir erro da API
                errorMessageP.textContent = data.error || 'Ocorreu um erro desconhecido durante o cálculo.';
                if(downloadResultsButton) downloadResultsButton.style.display = 'none'; // Esconde o botão em caso de erro
                 // Limpar resultados anteriores se o cálculo falhar
                resultsTableDiv.innerHTML = '';
                materialCostsDiv.innerHTML = '';
                footerNotes.style.display = 'none';
            }
        } catch (error) {
            // Remover indicador de carregamento
             document.getElementById('calculator-loading-indicator')?.remove();
            // Exibir erro de comunicação
            console.error('Erro durante a comunicação com a API da Calculadora:', error);
            errorMessageP.textContent = 'Erro de comunicação com a API: ' + error.message;
             if(downloadResultsButton) downloadResultsButton.style.display = 'none'; // Esconde o botão em caso de erro
             // Limpar resultados anteriores em caso de erro de comunicação
            resultsTableDiv.innerHTML = '';
            materialCostsDiv.innerHTML = '';
            footerNotes.style.display = 'none';
        }
        resultsContainer.style.display = 'block'; // Sempre mostra o contêiner de resultados/erro
    });

    // displayResults function - Usa elementos do Shadow DOM e dados PASSADOS como argumento
    function displayResults(document, resultsData) { // Recebe os dados processados completos
        const currentResultsTableDiv = document.getElementById('results-table-widget');
        const currentMaterialCostsDiv = document.getElementById('material-costs-widget');
        const currentFooterNotes = document.getElementById('footer-notes'); // Acessa do escopo superior

        // Garantir que os elementos existem antes de usar
        if (!currentResultsTableDiv || !currentMaterialCostsDiv || !currentFooterNotes) {
            console.error("Elementos de display de resultados não encontrados no Shadow DOM.");
            return;
        }

        // --- Exibir Tabela de Segmentos ---
        let tableHTML = '<table><thead><tr><th>Tipo</th><th>Comp. Original (m)</th><th>Desconto Conector (m)</th><th>Comp. Final (m)</th><th>Qtd.</th><th>Ângulo (\u03B1)</th></tr></thead><tbody>';

        if (resultsData.segmentResultsForDisplay) {
             resultsData.segmentResultsForDisplay.forEach(segment => {
                 const originalLengthRounded = customRound(segment.originalLength);
                 const discountRounded = customRound(segment.discount);
                 const finalLengthRounded = customRound(segment.finalLength);

                 tableHTML += `<tr><td>${segment.type}</td><td>${originalLengthRounded}</td><td>${discountRounded}</td><td>${finalLengthRounded > 0 ? finalLengthRounded : 'N/A'}</td><td>${segment.quantity}</td><td>${segment.angle !== 'N/D' ? segment.angle.toFixed(2) + '\u00B0' : 'N/A'}</td></tr>`; // Mostrar N/A se comp. final <= 0
             });
        } else {
             tableHTML += `<tr><td colspan="6">Dados dos segmentos não disponíveis.</td></tr>`;
        }

        tableHTML += '</tbody></table>';
        currentResultsTableDiv.innerHTML = tableHTML;

        // --- Exibir Recursos Materiais ---
        let materialHTML = '<h4>Recursos Materiais:</h4><ul>';

        // Acessar dados de resultsData (garantindo que são números ou usar N/A)
        const numVertices = typeof resultsData.total_vertices === 'number' ? resultsData.total_vertices : 'N/A';
        const totalSegments = typeof resultsData.calculatedTotalSegments === 'number' ? resultsData.calculatedTotalSegments : 'N/A';
        const totalLinearMeters = typeof resultsData.calculatedTotalLinearMeters === 'number' ? resultsData.calculatedTotalLinearMeters : 'N/A';
        const poleDiameterCm = resultsData.usedPoleDiameterCm; // Usar o diâmetro usado

        materialHTML += `<li>Número de Vértices: ${numVertices}</li>`;
        materialHTML += `<li>Número Total de Varas: ${totalSegments}</li>`;
        materialHTML += `<li>Total de Metros Lineares de Varas de Bambu: ${typeof totalLinearMeters === 'number' ? totalLinearMeters.toFixed(2) : 'N/A'} m</li>`;

        const numConectores = typeof totalSegments === 'number' ? totalSegments * 2 : 'N/A';
        materialHTML += `<li>Número de Conectores Utilizados: ${typeof numConectores === 'number' ? numConectores : 'N/A'} (2 por vara)</li>`;

        let cableLengthPerRod = 2;
        if (typeof poleDiameterCm === 'number' && poleDiameterCm >= 6.5) {
            cableLengthPerRod = 3;
        }
        const totalCableLength = typeof totalSegments === 'number' ? totalSegments * cableLengthPerRod : 'N/A';
         materialHTML += `<li>Cabo de Aço: ${typeof totalCableLength === 'number' ? totalCableLength : 'N/A'} m</li>`;

        materialHTML += `<li>Número de Sapatilhas: ${typeof totalSegments === 'number' ? totalSegments * 2 : 'N/A'}</li>`;
        materialHTML += `<li>Prensa Cabo: ${typeof totalSegments === 'number' ? totalSegments * 4 : 'N/A'}</li>`;
        materialHTML += `<li>Arruelas: ${typeof totalSegments === 'number' ? totalSegments * 4 : 'N/A'}</li>`;
        materialHTML += `<li>Parafusos com Porcas: ${typeof numConectores === 'number' ? numConectores : 'N/A'}</li>`;

        let puUg132aMl = 0;
        if (typeof poleDiameterCm === 'number') {
             if (poleDiameterCm > 0 && poleDiameterCm <= 5) {
                 puUg132aMl = 30 * (typeof totalLinearMeters === 'number' ? totalLinearMeters : 0);
             } else if (poleDiameterCm > 5 && poleDiameterCm <= 10) {
                 puUg132aMl = 60 * (typeof totalLinearMeters === 'number' ? totalLinearMeters : 0);
             }
        }
        const displayPuUg132a = typeof puUg132aMl === 'number' && puUg132aMl > 0 ? (puUg132aMl >= 1000 ? `${(puUg132aMl / 1000).toFixed(2)} L` : `${puUg132aMl.toFixed(2)} ml`) : 'N/A';
        materialHTML += `<li>PU Vegetal UG132A: ${displayPuUg132a} híbrido (tratamento térmico)</li>`;

        let puMamonexMl = 0;
        if (typeof poleDiameterCm === 'number') {
             if (poleDiameterCm > 0 && poleDiameterCm <= 5) {
                puMamonexMl = 100 * (typeof totalSegments === 'number' ? totalSegments : 0);
             } else if (poleDiameterCm > 5 && poleDiameterCm <= 10) {
                puMamonexMl = 150 * (typeof totalSegments === 'number' ? totalSegments : 0);
             }
         }
        const displayPuMamonex = typeof puMamonexMl === 'number' && puMamonexMl > 0 ? (puMamonexMl >= 1000 ? `${(puMamonexMl / 1000).toFixed(2)} L` : `${puMamonexMl.toFixed(2)} ml`) : 'N/A';
        materialHTML += `<li>PU Vegetal Mamonex RD70: ${displayPuMamonex} (tratamento imunizante)</li>`;


        const vertexDiameterDisplay = resultsData.calculatedVertexDiameterDisplay; // Usar o valor já calculado
        const connectorLengthCm = resultsData.calculatedConnectorLengthCm; // Usar o valor já calculado
        const SPACING_MM_DISPLAY = 4; // Para texto explicativo (usar constante local)

        materialHTML += `<li>Diâmetro dos Vértices (estimado): ${vertexDiameterDisplay}</li>`;

        const numVerticesDisplay = typeof numVertices === 'number' ? numVertices : 'N/A'; // Usar o valor já calculado
        materialHTML += `<li>Número de Anéis de Borracha: ${numVerticesDisplay} (Para união)</li>`;
        materialHTML += `<li>Abraçadeiras (Nylon ou Inox): ${numVerticesDisplay} (Opcional, para reforço nos vértices)</li>`;
        materialHTML += `</ul>`;
        currentMaterialCostsDiv.innerHTML = materialHTML;

        // --- Exibir Observações no Rodapé ---
        let notesHTML = `
            <p><strong>Observações:</strong></p>
            <ul>
                <li>Diâmetro das Varas: ${typeof poleDiameterCm === 'number' ? poleDiameterCm + ' cm' : 'Não informado. O cálculo de PU e Cabo de Aço pode ser afetado.'}</li>
                <li>O cálculo do diâmetro dos vértices (${vertexDiameterDisplay}) considera uma união de 6 varas dispostas circularmente, cada una com o diâmetro da vara, e com um espaçamento de ${SPACING_MM_DISPLAY}mm entre elas. Este diâmetro define o comprimento do conector, que é metade do diâmetro do vértice (${connectorLengthCm} cm), e é crucial para evitar colapsos estruturais.</li>
                <li>A especificação do cabo de aço será determinada pela carga solicitada, espécie e diâmetro do bambu a ser utilizado.</li>
                <li>Os furos nas varas de bambu para a passagem do cabo devem ser feitos nas extremidades a um ângulo de 45° no sentido da entrada, com diâmetro correspondente à espessura do cabo.</li>
                <li>Serão realizados dois furos perpendiculares a 3cm da extremidade e dois furos perpendiculares a 5cm da extremidade.</li>
                <li>A especificação de parafusos com porcas pode variar de acordo com o esforço e peso recebido pela estrutura. Consulte um engenheiro.</li>
                <li>Recomenda-se tratamento completo (curagem e imunização) do bambu antes da montagem.</li>
                <li>Este cálculo é uma estimativa. Variações na espécie de bambu, métodos de tratamento e tolerâncias de fabricação podem impactar os resultados finais.</li>
            </ul>
        `;
        currentFooterNotes.innerHTML = notesHTML; // Usa a variável footerNotes do escopo superior
        currentFooterNotes.style.display = 'block';
    } // Fim de displayResults

    // Função para gerar o arquivo Markdown (Usa dados armazenados em lastCalculatedData)
    function generateMarkdown() {
         // Acessa os dados armazenados no escopo superior (lastCalculatedData, lastSelectedSolid, etc.)
        const diameter = document.getElementById('diameter-input-widget').value; // Pega o diâmetro atual do input

        const data = lastCalculatedData; // Dados completos do último cálculo
        if (!data) {
             console.error("Não há dados de cálculo para gerar o Markdown.");
             return ''; // Retorna string vazia se não há dados
        }

        // Acessa os dados específicos necessários do objeto data
        const base_solid = lastSelectedSolid; // Seleções
        const frequency = lastSelectedFreq;
        const truncation = lastSelectedTrunc;
        const poleDiameterCm = data.usedPoleDiameterCm; // Diâmetro usado no cálculo

        const totalLinearMetersMd = data.calculatedTotalLinearMeters; // Totais calculados
        const totalSegmentsMd = data.calculatedTotalSegments;
        const numVerticesMd = typeof data.total_vertices === 'number' ? data.total_vertices : 'N/A'; // Vértices originais da API

        const segmentResultsForDisplay = data.segmentResultsForDisplay; // Resultados por segmento

        const vertexDiameterDisplayMd = data.calculatedVertexDiameterDisplay; // Valores de vértice calculados
        const connectorLengthCmMd = data.calculatedConnectorLengthCm;
        const SPACING_MM_MD = 4; // Para texto explicativo


        let markdownContent = `# Resultados da Calculadora de Domos\n\n`;
        markdownContent += `## Detalhes do Domo\n`;
        markdownContent += `- **Sólido Base:** ${base_solid}\n`;
        markdownContent += `- **Frequência/Variante:** ${frequency}\n`;
        markdownContent += `- **Tipo de Esfera (Truncagem):** ${truncation}\n`;
        markdownContent += `- **Diâmetro do Domo:** ${diameter} m\n`; // Usa o valor atual do input
        markdownContent += `- **Diâmetro das Varas:** ${typeof poleDiameterCm === 'number' ? poleDiameterCm + ' cm' : 'Não informado.'}\n`;
        markdownContent += `\n`;

        markdownContent += `## Comprimento dos Segmentos\n\n`;
        markdownContent += `| Tipo | Comp. Original (m) | Desconto Conector (m) | Comp. Final (m) | Qtd. | Ângulo (α) |\n`;
        markdownContent += `|---|---|---|---|---|---|\n`;
        if (segmentResultsForDisplay) {
             segmentResultsForDisplay.forEach(segment => {
                 const originalLengthRounded = customRound(segment.originalLength);
                 const discountRounded = customRound(segment.discount);
                 const finalLengthRounded = customRound(segment.finalLength);
                 markdownContent += `| ${segment.type} | ${originalLengthRounded} | ${discountRounded} | ${finalLengthRounded > 0 ? finalLengthRounded : 'N/A'} | ${segment.quantity} | ${segment.angle !== 'N/D' ? segment.angle.toFixed(2) + '°' : 'N/A'} |\n`;
             });
        } else {
              markdownContent += `| N/A | N/A | N/A | N/A | N/A | N/A |\n`;
        }
        markdownContent += `\n`;

        markdownContent += `## Recursos Materiais\n\n`;

        markdownContent += `- Número de Vértices: ${numVerticesMd}\n`;
        markdownContent += `- Número Total de Varas: ${typeof totalSegmentsMd === 'number' ? totalSegmentsMd : 'N/A'}\n`;
        markdownContent += `- Total de Metros Lineares de Varas de Bambu: ${typeof totalLinearMetersMd === 'number' ? totalLinearMetersMd.toFixed(2) : 'N/A'} m\n`;

        const numConectoresMd = typeof totalSegmentsMd === 'number' ? totalSegmentsMd * 2 : 'N/A';
        markdownContent += `- Número de Conectores Utilizados: ${typeof numConectoresMd === 'number' ? numConectoresMd : 'N/A'} (2 por vara)\n`;

        let cableLengthPerRodMd = 2;
        if (typeof poleDiameterCm === 'number' && poleDiameterCm >= 6.5) {
            cableLengthPerRodMd = 3;
        }
        const totalCableLengthMd = typeof totalSegmentsMd === 'number' ? totalSegmentsMd * cableLengthPerRodMd : 'N/A';
        markdownContent += `- Cabo de Aço: ${typeof totalCableLengthMd === 'number' ? totalCableLengthMd : 'N/A'} m\n`;

        markdownContent += `- Número de Sapatilhas: ${typeof totalSegmentsMd === 'number' ? totalSegmentsMd * 2 : 'N/A'}\n`;
        markdownContent += `- Prensa Cabo: ${typeof totalSegmentsMd === 'number' ? totalSegmentsMd * 4 : 'N/A'}\n`;
        markdownContent += `- Arruelas: ${typeof totalSegmentsMd === 'number' ? totalSegmentsMd * 4 : 'N/A'}\n`;
        markdownContent += `- Parafusos com Porcas: ${typeof numConectoresMd === 'number' ? numConectoresMd : 'N/A'}\n`;

        let puUg132aMlMd = 0;
        if (typeof poleDiameterCm === 'number') {
            if (poleDiameterCm > 0 && poleDiameterCm <= 5) {
                puUg132aMlMd = 30 * (typeof totalLinearMetersMd === 'number' ? totalLinearMetersMd : 0);
            } else if (poleDiameterCm > 5 && poleDiameterCm <= 10) {
                puUg132aMlMd = 60 * (typeof totalLinearMetersMd === 'number' ? totalLinearMetersMd : 0);
            }
        }
         const displayPuUg132aMd = typeof puUg132aMlMd === 'number' && puUg132aMlMd > 0 ? (puUg132aMlMd >= 1000 ? `${(puUg132aMlMd / 1000).toFixed(2)} L` : `${puUg132aMlMd.toFixed(2)} ml`) : 'N/A';
        markdownContent += `- PU Vegetal UG132A: ${displayPuUg132aMd} híbrido (tratamento térmico)\n`;

        let puMamonexMlMd = 0;
        if (typeof poleDiameterCm === 'number') {
             if (poleDiameterCm > 0 && poleDiameterCm <= 5) {
                puMamonexMlMd = 100 * (typeof totalSegmentsMd === 'number' ? totalSegmentsMd : 0);
             } else if (poleDiameterCm > 5 && poleDiameterCm <= 10) {
                puMamonexMlMd = 150 * (typeof totalSegmentsMd === 'number' ? totalSegmentsMd : 0);
             }
         }
        const displayPuMamonexMd = typeof puMamonexMlMd === 'number' && puMamonexMlMd > 0 ? (puMamonexMlMd >= 1000 ? `${(puMamonexMlMd / 1000).toFixed(2)} L` : `${puMamonexMlMd.toFixed(2)} ml`) : 'N/A';
        markdownContent += `- PU Vegetal Mamonex RD70: ${displayPuMamonexMd} (tratamento imunizante)\n`;

        markdownContent += `- Diâmetro dos Vértices (estimado): ${vertexDiameterDisplayMd}\n`;

        markdownContent += `- Número de Anéis de Borracha: ${numVerticesMd} (Para união)\n`;
        markdownContent += `- Abraçadeiras (Nylon ou Inox): ${numVerticesMd} (Opcional, para reforço nos vértices)\n`;
        markdownContent += `\n`;

        markdownContent += `\n---\n\n`;
        markdownContent += `## Observações\n`;
        // Recria as observações diretamente aqui para o Markdown
         markdownContent += `- Diâmetro das Varas: ${typeof poleDiameterCm === 'number' ? poleDiameterCm + ' cm' : 'Não informado.'}\n`;
        markdownContent += `- O cálculo do diâmetro dos vértices (${vertexDiameterDisplayMd}) considera uma união de 6 varas dispostas circularmente, cada una com o diâmetro da vara, e com um espaçamento de ${SPACING_MM_MD}mm entre elas. Este diâmetro define o comprimento do conector, que é metade do diâmetro do vértice (${connectorLengthCmMd} cm), e é crucial para evitar colapsos estruturais.\n`;
        markdownContent += `- A especificação do cabo de aço será determinada pela carga solicitada, espécie e diâmetro do bambu a ser utilizado.\n`;
        markdownContent += `- Os furos nas varas de bambu para a passagem do cabo devem ser feitos nas extremidades a um ângulo de 45° no sentido da entrada, com diâmetro correspondente à espessura do cabo.\n`;
        markdownContent += `- Serão realizados dois furos perpendiculares a 3cm da extremidade e dois furos perpendiculares a 5cm da extremidade.\n`;
        markdownContent += `- A especificação de parafusos com porcas pode variar de acordo com o esforço e peso recebido pela estrutura. Consulte um engenheiro.\n`;
        markdownContent += `- Recomenda-se tratamento completo (curagem e imunização) do bambu antes da montagem.\n`;
        markdownContent += `- Este cálculo é uma estimativa. Variações na espécie de bambu, métodos de tratamento e tolerâncias de fabricação podem impactar os resultados finais.\n`;


        return markdownContent; // Retorna a string Markdown completa
    }

    // Event Listener para o botão de Download (usa generateMarkdown e lastCalculatedData)
    if (downloadResultsButton) {
        downloadResultsButton.addEventListener('click', () => {
            const currentErrorMessageP = document.getElementById('error-message-widget');

            if (!lastCalculatedData) { // Verifica se já houve um cálculo bem sucedido
                if(currentErrorMessageP) currentErrorMessageP.textContent = 'Por favor, execute um cálculo antes de baixar os resultados.';
                return;
            }
            const markdown = generateMarkdown(); // Chama generateMarkdown
            if (!markdown) { // Verifica se generateMarkdown retornou conteúdo
                 if(currentErrorMessageP) currentErrorMessageP.textContent = 'Erro ao gerar o conteúdo do relatório.';
                 return;
            }

            // Gera um nome de arquivo mais amigável e compatível
            const filename = `resultados_domo_${lastSelectedSolid.replace(/[^a-zA-Z0-9]/g, '_')}_${lastSelectedFreq.replace(/[^a-zA-Z0-9]/g, '_')}_${lastSelectedTrunc.replace(/[^a-zA-Z0-9]/g, '_')}.md`.toLowerCase();

            const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8;' });
            const link = document.createElement('a'); // Cria link no DOM principal (correto para downloads)
            if (link.download !== undefined) {
                link.setAttribute('href', URL.createObjectURL(blob));
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link); // Adiciona link no DOM principal
                link.click();
                document.body.removeChild(link);
            } else {
                alert('Seu navegador não suporta o download automático. Copie o texto abaixo:\n\n' + markdown);
            }
        });
    } // warning se button não for encontrado já está no início

    // Inicializa o formulário (popula selects e adiciona listeners iniciais)
    populateSelect(solidSelect, Object.keys(DOME_DATA));
    solidSelect.addEventListener('change', updateFreqOptions);
    freqSelect.addEventListener('change', updateTruncOptions);

    updateFreqOptions(); // Chama no início para popular os menus iniciais

    // Event listener para a nota de N/A no campo de diâmetro da vara
     if (poleDiameterInput && poleDiameterNote) {
        poleDiameterInput.addEventListener('input', () => {
            // Verificar se o valor é um número válido e maior que 0
            if (isNaN(parseFloat(poleDiameterInput.value)) || parseFloat(poleDiameterInput.value) <= 0) {
                poleDiameterNote.style.display = 'block';
            } else {
                poleDiameterNote.style.display = 'none';
            }
        });
        // Define o estado inicial da nota com base no valor padrão (5)
        if (isNaN(parseFloat(poleDiameterInput.value)) || parseFloat(poleDiameterInput.value) <= 0) {
             poleDiameterNote.style.display = 'block';
         } else {
             poleDiameterNote.style.display = 'none';
         }
     }


     console.log('Takwara Calculator: Inicialização concluída.');
} // Fim da função initializeTakwaraCalculator


// OUVINTE PRINCIPAL: Escuta pelo nosso evento customizado 'takwara:tools-ready'
document.addEventListener('takwara:tools-ready', (event) => {
    const document = event.detail.document;
    if (document) {
        initializeTakwaraCalculator(document);
    } else {
        console.error('Takwara Calculator: Evento "tools-ready" recebido, mas document não encontrado no detalhe.');
    }
});
}


// ===================================================================
// SEÇÃO 4: LÓGICA DO GRAFO
// ===================================================================
function initializeGrafo() {
    console.log('Grafo: Inicializando...');
    // Pega o shadowRoot da Tool Box que é passado no detalhe do evento
    const shadowRoot = event.detail.shadowRoot;
     // Se o shadowRoot foi recebido, chama a função de inicialização do grafo
     if (shadowRoot) {
        initializeTakwaraGraph(shadowRoot);
    } else {
        // Loga um erro se o shadowRoot não estiver disponível
        console.error('Takwara Graph: Evento "tools-ready" recebido, mas shadowRoot não encontrado no detalhe.');
    }
});

// --- FUNÇÃO DE INICIALIZAÇÃO DO GRAFO ---
// Recebe o shadowRoot da Tool Box como argumento
function initializeTakwaraGrafo() {
    console.log('Takwara Graph: A inicializar após receber o sinal "tools-ready".');

    // Dados do grafo - Definidos DENTRO da função para evitar erros de escopo
    const nodes = [
        { id: 1, label: "Bambu", color: '#90EE90', path: 'docs/bambu/index.md' }, // path para a página do documento
        { id: 2, label: "Tecnologia Takwara", color: '#32CD32', path: 'docs/tecnologia/index.md' },
        { id: 3, label: "Conexões Geodésicas", color: '#FFFFE0', path: 'docs/tecnologia/geodesicas.md' },
        { id: 4, label: "PU Vegetal", color: '#FFFFE0', path: 'docs/tecnologia/pu-vegetal.md' },
        { id: 5, label: "Forno Ecológico", color: '#FFFFE0', path: 'docs/tecnologia/forno-ecologico.md' },
        // Adicione mais nós aqui, definindo o 'path' para o arquivo .md correspondente
        { id: 6, label: "README", color: '#ADD8E6', path: 'docs/README.md' } // Exemplo: nó para o README
    ];
    const edges = [
        { from: 1, to: 2, label: "base da", arrows: "to" },
        { from: 2, to: 3, label: "usa", arrows: "to" },
        { from: 2, to: 4, label: "usa", arrows: "to" },
        { from: 2, to: 5, label: "usa", arrows: "to" },
        { from: 1, to: 4, label: "baseado em", arrows: "to" },
        { from: 1, to: 5, label: "inclui um", arrows: "to" },
        { from: 3, to: 1, label: "requer", arrows: "to" },
        // Adicione mais arestas aqui
         { from: 2, to: 6, label: "documentado em", arrows: "to" } // Exemplo: link da Tecnologia para o README
    ];


    // Buscar o contêiner do grafo DENTRO do Shadow DOM
    // Este elemento deve existir em partials/widget-grafo.html (que é incluído em widget-tools.html)
    const container = document.getElementById('knowledge-graph'); // Usa shadowRoot.getElementById

    // --- VERIFICAÇÃO ESSENCIAL: O contêiner do grafo deve existir no Shadow DOM ---
    if (!container) {
        console.error('Takwara Graph: Container "#knowledge-graph" não encontrado no Shadow DOM. Verifique o HTML do template `partials/widget-grafo.html`.');
        return; // Aborta a inicialização se o contêiner não for encontrado
    }

    // Verificar se a biblioteca vis.js está disponível globalmente (mantido)
    if (typeof vis === 'undefined' || !vis.DataSet || !vis.Network) {
        console.error('Takwara Graph: A biblioteca vis.js não está carregada. Verifique se o script vis.js está incluído (mkdocs.yml).');
        return;
    }

    // Cria os DataSets para nós e arestas (mantido)
    const data = {
        nodes: new vis.DataSet(nodes),
        edges: new vis.DataSet(edges),
    };

    // Opções de visualização do grafo (mantido, com navigationButtons: false)
    const options = {
        nodes: {
            shape: 'dot',
            size: 20,
            font: { size: 14, color: '#333', face: 'Arial' },
            borderWidth: 2,
            shadow: true
        },
        edges: {
            width: 2,
            color: { inherit: 'from' },
            arrows: { to: { enabled: true, scaleFactor: 0.6 } },
            dashes: true,
            shadow: true
        },
        physics: {
             enabled: true,
             barnesHut: {
                  gravitationalConstant: -30000,
                  centralGravity: 0.5,
                  springLength: 150,
                  springConstant: 0.05,
                  damping: 0.09,
                  avoidOverlap: 0.5
             },
            solver: 'barnesHut',
            timestep: 0.5,
            stabilization: { iterations: 200, updateInterval: 25 },
        },
        interaction: {
             navigationButtons: false, // <--- DESATIVADO!
             keyboard: false,
             zoomView: true,
             dragNodes: true,
             dragView: true,
             multiselect: false,
             hover: true,
             tooltipDelay: 300,
        },
        configure: {
             enabled: false // Desativa o UI de configuração
        },
         autoResize: true, // Permite que o grafo se ajuste ao tamanho do contêiner
         height: '100%', // Configura a altura para 100% do contêiner pai (#knowledge-graph)
         width: '100%' // Configura a largura para 100% do contêiner pai
    };

    // Cria a rede vis.js no contêiner DENTRO do Shadow DOM
    const network = new vis.Network(container, data, options); // Passa o contêiner do Shadow DOM

    // Opcional: Eventos para interatividade adicional (tooltips, etc.) (mantido)


    // Adiciona funcionalidade de clique para navegar para as páginas (mantida a lógica original)
    network.on("selectNode", function (params) {
        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            // Busca o objeto nó com os dados (incluindo node.path) do DataSet
            const node = data.nodes.get(nodeId);

            // --- PASSO 1: Verificar se o nó tem um 'path' ---
            if (node.path) {
                // node.path é a string que define o caminho Markdown (ex: 'docs/tecnologia/geodesicas.md')

                // PASSO 2: Transformar 'docs/caminho/arquivo.md' no caminho relativo web '/caminho/arquivo/'
                // - Remove 'docs/' do início
                // - Remove '.md' do final
                // - Adiciona '/' no final (porque MkDocs usa URL com barra final)
                let targetPath = node.path.replace('docs/', '').replace('.md', '/');

                // PASSO 3: Tratar o caso especial do README.md ('README/') para que a URL seja a raiz ('/')
                if (targetPath === 'README/') {
                    targetPath = ''; // Caminho vazio '' representa a raiz do site MkDocs
                }

                // PASSO 4: Construir a URL COMPLETA baseada no ambiente (Local vs Publicado)
                // Detecta se está rodando localmente (mkdocs serve)
                const isLocal = window.location.hostname === '127.0.0.1' || window.location.hostname === 'localhost' || window.location.port === '8000';

                let finalUrl;
                if (isLocal) {
                     // AMBIENTE LOCAL: URL base é a origem + '/' + targetPath
                     finalUrl = window.location.origin + '/' + targetPath;

                } else {
                     // AMBIENTE PUBLICADO (GitHub Pages): URL base é a origem + prefixo do repositório + targetPath
                     // **AJUSTE '/Takwara-Tech/'** se o nome do seu repositório no GitHub Pages for diferente!
                     const repoBase = '/Takwara-Tech/'; // Prefixo para o nome do repositório no GitHub Pages
                     finalUrl = window.location.origin + repoBase + targetPath;
                }

                // PASSO 5: Navegar para a URL final
                console.log("Navegando para:", finalUrl); // Mostra a URL gerada no console
                window.location.href = finalUrl; // Navega o navegador para essa URL

            } else {
                // Se o nó não tem 'path' definido nos dados, não faz nada ou mostra um aviso
                console.warn(`Nó clicado (${nodeId}) não possui uma propriedade 'path'. Não é possível navegar.`);
            }
        }
    });

     console.log('Takwara Graph: Inicialização concluída.');
} // Fim da função initializeTakwaraGraph